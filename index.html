<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Minesweeper (eazy mode)</title>
    <style>
      body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
      }

      #status {
        margin-bottom: 10px;
        font-weight: bold;
      }

      #board {
        display: grid;
        grid-template-columns: repeat(20, 30px);
        grid-auto-rows: 30px;
        gap: 2px;
      }

      .cell {
        width: 30px;
        height: 30px;
        background: #ccc;
        border: 1px solid #999;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        font-size: 16px;
        user-select: none;
      }

      .cell.revealed {
        background: #eee;
        cursor: default;
      }

      .cell.mine {
        background: #e57373;
        color: #000;
      }

      .cell.safe {
        background: #aed581;
      }

      .cell.disabled {
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="status">Click any tile to start.</div>
    <div id="board"></div>

    <!-- Leaderboard UI -->
    <div id="leaderboard" style="margin-top:20px; width: 320px; text-align: left;">
      <h3 style="margin:6px 0">Global Leaderboard</h3>
      <div style="display:flex; gap:8px; margin-bottom:12px;">
        <input id="playerName" placeholder="Your name" style="flex:1; padding:6px" />
        <button id="refreshLeaderboardBtn">Refresh</button>
      </div>
      <ol id="leaderList" style="padding-left:18px; margin:0;">
        <li>Loading...</li>
      </ol>
    </div>
    <script>
      const rows = 20;
      const cols = 20;

      const boardEl = document.getElementById("board");
      const statusEl = document.getElementById("status");

      let firstClickDone = false; 
      let firstSafeIndex = null;

      // Create grid cells
      const cells = [];
      for (let i = 0; i < rows * cols; i++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.index = i;
        cell.addEventListener("click", onCellClick);
        boardEl.appendChild(cell);
        cells.push(cell);
      }

      function indexToRC(index) {
        return {
          r: Math.floor(index / cols),
          c: index % cols,
        };
      }

      function rcToIndex(r, c) {
        return r * cols + c;
      }

      function getNeighbors(index) {
        const { r, c } = indexToRC(index);
        const neighbors = [];
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const nr = r + dr;
            const nc = c + dc;
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
              neighbors.push(rcToIndex(nr, nc));
            }
          }
        }
        return neighbors;
      }

      function onCellClick(e) {
        const cell = e.currentTarget;
        const index = parseInt(cell.dataset.index, 10);

        // First click: mark this as safe, everything else as mines
        if (!firstClickDone) {
          firstClickDone = true;
          firstSafeIndex = index;

          // Mark all cells except this one as mines (internally)
          for (let i = 0; i < cells.length; i++) {
            if (i !== firstSafeIndex) {
              cells[i].dataset.isMine = "true";
            } else {
              cells[i].dataset.isMine = "false";
            }
          }

          revealSafeCell(index);
          statusEl.textContent =
            "Crazy luck!";
          return;
        }

        // After the first click, any non-safe tile is a mine
        if (cell.dataset.isMine === "true") {
          revealAllMines();
          statusEl.textContent = "Boom! You clicked a mine. Game over.";
          disableBoard();
        } else {
          // This should only be the firstSafeIndex if clicked again
          revealSafeCell(index);
        }
      }

      function revealSafeCell(index) {
        const cell = cells[index];
        if (cell.classList.contains("revealed")) return;

        const neighbors = getNeighbors(index);
        // Count mines around this cell. Since all others are mines:
        // adjacent mines = number of neighbors.
        const mineCount = neighbors.length;

        cell.classList.add("revealed", "safe");
        cell.textContent = mineCount > 0 ? mineCount : "";
        // After revealing, check if any safe cells remain; if none, player cleared all safe tiles (win)
        try {
          const remainingSafe = Array.from(cells).filter(c => c.dataset.isMine === 'false' && !c.classList.contains('revealed')).length;
          if (remainingSafe === 0) {
            statusEl.textContent = 'You cleared all safe tiles!';
            disableBoard();
            // auto-submit final score
            setTimeout(() => {
              if (typeof autoSubmitScore === 'function') autoSubmitScore();
            }, 50);
          }
        } catch (e) {
          // ignore DOM errors
        }
      }

      function revealAllMines() {
        for (let i = 0; i < cells.length; i++) {
          const cell = cells[i];
          if (cell.dataset.isMine === "true") {
            cell.classList.add("revealed", "mine");
            cell.textContent = "ðŸ’£";
          }
        }
        // Make sure the safe one looks safe
        if (firstSafeIndex !== null) {
          cells[firstSafeIndex].classList.add("safe");
        }
        // When the game ends (boom), auto-submit the current score
        setTimeout(() => {
          if (typeof autoSubmitScore === 'function') autoSubmitScore();
        }, 50);
      }

      function disableBoard() {
        for (const cell of cells) {
          cell.classList.add("disabled");
        }
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/umd/supabase.min.js"></script>
    <script>
      // --- Configuration: replace these with your Supabase project's values ---
      // You can set these directly here (development) or add them as Netlify environment variables
      // and substitute during your build. For a static HTML site, putting the anon key in the client
      // is acceptable: it's the public anon key intended for client usage.
      const SUPABASE_URL = "https://htxdmxbzxdggjwjeyvvv.supabase.co"; // e.g. https://abcd1234.supabase.co
      const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh0eGRteGJ6eGRnZ2p3amV5dnZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ2OTIxODMsImV4cCI6MjA4MDI2ODE4M30.NdJ-GhhaB2QdedHCoe1REn3KBU4DAtyQNu_p-liAKQg";

      const hasSupabase = SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL.indexOf("REPLACE") === -1;
      const supabase = hasSupabase ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;

      const leaderListEl = document.getElementById("leaderList");
      const refreshLeaderboardBtn = document.getElementById("refreshLeaderboardBtn");
      const playerNameInput = document.getElementById("playerName");

      function getLocalScoreGuess() {
        try {
          return document.querySelectorAll('.cell.safe.revealed').length || 0;
        } catch (e) { return 0; }
      }

      async function fetchLeaderboard() {
        if (!hasSupabase) {
          leaderListEl.innerHTML = "<li>Supabase keys not configured.</li>";
          return;
        }
        leaderListEl.innerHTML = "<li>Loading...</li>";
        try {
          const { data, error } = await supabase
            .from('leaderboard')
            .select('id, name, score, created_at')
            .order('score', { ascending: false })
            .limit(10);
          if (error) throw error;
          if (!data || data.length === 0) {
            leaderListEl.innerHTML = "<li>No scores yet.</li>";
            return;
          }
          leaderListEl.innerHTML = data.map(row => `<li>${escapeHtml(row.name)} â€” ${row.score}</li>`).join('');
        } catch (err) {
          leaderListEl.innerHTML = `<li>Error loading leaderboard: ${escapeHtml(err.message || err)}</li>`;
        }
      }

      async function submitScore(name, score) {
        if (!hasSupabase) {
          console.warn('Supabase not configured; skipping submit');
          return;
        }
        try {
          const { error } = await supabase.from('leaderboard').insert([{ name, score }]);
          if (error) throw error;
          await fetchLeaderboard();
        } catch (err) {
          console.error('Submit failed:', err.message || err);
        }
      }

      // Auto-submit the player's score (cleared tiles) on game end.
      async function autoSubmitScore() {
        const name = (playerNameInput.value || 'Anonymous').trim() || 'Anonymous';
        const score = getLocalScoreGuess();
        // mark name input readonly after submit to avoid multiple submissions
        try {
          playerNameInput.disabled = true;
        } catch (e) {}
        await submitScore(name, score);
      }

      function escapeHtml(s) {
        return String(s)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      refreshLeaderboardBtn.addEventListener('click', fetchLeaderboard);
      // Fetch on load
      fetchLeaderboard();
    </script>
  </body>
</html>